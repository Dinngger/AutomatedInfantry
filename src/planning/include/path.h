#ifndef PATH_H
#define PATH_H

#include <iostream>
#include <cstring>
#include <vector>
#include <string>

#include <ros/ros.h>
#include <tf/transform_datatypes.h>
#include <nav_msgs/Path.h>
#include <geometry_msgs/PoseStamped.h>
#include <geometry_msgs/PoseArray.h>
#include <visualization_msgs/MarkerArray.h>

#include "node2d.h"
#include "constants.h"
#include "helper.h"
namespace HybridPlanner {
/*!
   \brief A class for tracing and visualizing the path generated by the Planner
*/
class Path {
 public:
  /// The default constructor initializing the path object and setting publishers for the same.
  Path() {
    std::string pathTopic;
    pathTopic = "/rPath";

    // TOPICS TO PUBLISH
    pubPath = n.advertise<nav_msgs::Path>(pathTopic, 1);

    // CONFIGURE THE CONTAINER
    path.header.frame_id = "map";
  }

  //  // __________
  //  // TRACE PATH
  //  /*!
  //     \brief Given a node pointer the path to the root node will be traced recursively
  //     \param node a 3D node, usually the goal node
  //     \param i a parameter for counting the number of nodes
  //  */
  //  void tracePath(const Node3D* node, int i = 0);
  /*!
     \brief Given a node pointer the path to the root node will be traced recursively
     \param node a 3D node, usually the goal node
     \param i a parameter for counting the number of nodes
  */
  void updatePath2D(std::vector<Node2D> nodePath);
  /*!
     \brief Adds a segment to the path
     \param node a 3D node
  */
  void addSegment2D(const Node2D& node);

  // ______________
  // PUBLISH METHODS

  /// Clears the path
  void clear();
  /// Publishes the path
  void publishPath() { pubPath.publish(path); }

 private:
  /// A handle to the ROS node
  ros::NodeHandle n;
  /// Publisher for the path as a spline
  ros::Publisher pubPath;
  /// Path data structure for visualization
  nav_msgs::Path path;
};
}
#endif // PATH_H
